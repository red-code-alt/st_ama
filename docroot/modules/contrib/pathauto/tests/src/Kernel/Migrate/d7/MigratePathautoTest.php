<?php

namespace Drupal\Tests\pathauto\Kernel\Migrate\d7;

use Drupal\Core\DependencyInjection\ContainerBuilder;
use Drupal\Core\Extension\ModuleInstallerInterface;
use Drupal\node\Entity\Node;
use Drupal\path_alias\AliasRepository;
use Drupal\pathauto\Entity\PathautoPattern;
use Drupal\pathauto\Plugin\migrate\process\PathautoPatternSelectionCriteria;
use Drupal\taxonomy\Entity\Term;
use Drupal\Tests\migrate_drupal\Kernel\d7\MigrateDrupal7TestBase;
use Drupal\Tests\pathauto\Traits\PathautoMigrationAssertionsTrait;

/**
 * Tests pathauto settings and pathauto pattern migrations.
 *
 * @group pathauto
 */
class MigratePathautoTest extends MigrateDrupal7TestBase {

  use PathautoMigrationAssertionsTrait;

  /**
   * Test is executed with forum enabled.
   *
   * @var bool
   */
  protected $withForum;

  /**
   * Multilingual test.
   *
   * @var bool
   */
  protected $multilingual = FALSE;

  /**
   * {@inheritdoc}
   */
  public static $modules = [
    'comment',
    'ctools',
    'datetime',
    'datetime_range',
    'image',
    'link',
    'filter',
    'file',
    'node',
    'path',
    'path_alias',
    'pathauto',
    'system',
    'pathauto_test_uuid_generator',
    'taxonomy',
    'telephone',
    'text',
    'token',
    'taxonomy',
    'menu_ui',
  ];

  /**
   * Returns the path to the file system fixture.
   */
  protected function getFilesystemFixturePath() {
    return implode(DIRECTORY_SEPARATOR, [
      DRUPAL_ROOT,
      drupal_get_path('module', 'migrate_drupal_ui'),
      'tests',
      'src',
      'Functional',
      'd7',
      'files',
    ]);
  }

  /**
   * {@inheritdoc}
   */
  public function register(ContainerBuilder $container) {
    parent::register($container);
    $container->register('stream_wrapper.private', 'Drupal\Core\StreamWrapper\PrivateStream')
      ->addTag('stream_wrapper', ['scheme' => 'private']);
  }

  /**
   * {@inheritdoc}
   */
  protected function setUp() {
    parent::setUp();
    $this->loadFixture(implode(DIRECTORY_SEPARATOR, [
      DRUPAL_ROOT,
      drupal_get_path('module', 'pathauto'),
      'tests',
      'fixtures',
      'drupal7.php',
    ]));

    $this->installConfig(static::$modules);
    $this->installSchema('node', ['node_access']);
    $this->installSchema('file', ['file_usage']);
    $this->installEntitySchema('file');
    $this->installEntitySchema('path_alias');

    // UUIDs used in selection criteria must be predictable.
    $this->container->get('state')->set('pathauto_test_uuid_generator.watch', PathautoPatternSelectionCriteria::class);
  }

  /**
   * Test pathauto migration from Drupal 7.
   *
   * @param bool $forum_enabled
   *   Whether forum module is enabled on the source site or not.
   *
   * @dataProvider providerPathautoMigrations
   */
  public function testPathautoMigrations(bool $forum_enabled) {
    $this->withForum = $forum_enabled;

    if ($this->multilingual) {
      $this->enableModules([
        'language',
        'content_translation',
      ]);
    }

    $this->sourceDatabase->update('system')
      ->fields(['status' => (int) $forum_enabled])
      ->condition('name', 'forum')
      ->condition('type', 'module')
      ->execute();

    $this->executeMigrations([
      'd7_pathauto_settings',
    ]);
    $this->assertPathautoSettings();

    $this->executeMigrations([
      'd7_node_type',
      'd7_pathauto_patterns:node:article',
      'd7_pathauto_patterns:node:blog',
      'd7_pathauto_patterns:node:et',
      'd7_pathauto_patterns:node_default',
    ]);

    $this->assertNodeArticlePattern();
    $this->assertNodeBlogPattern();
    $this->assertNodeEtPattern();
    $this->assertNodePattern();

    $this->executeMigrations([
      'd7_taxonomy_vocabulary',
      'd7_pathauto_patterns:taxonomy_term',
      'd7_pathauto_patterns:taxonomy_term_default',
    ]);
    $this->assertTermTagsPattern();
    $this->assertTermPattern();
    if ($forum_enabled) {
      $this->assertTermForumsPattern();
    }
    else {
      $this->assertNull(PathautoPattern::load('forum'));
    }

    // Execute the rest of the migrations. For now, this is equal to executing
    // "d7_pathauto_patterns:user_default".
    $this->executeMigrations([
      'd7_pathauto_patterns',
    ]);
    $this->assertUserPattern();

    // Pathauto states (the state whether a path alias for a given entity was
    // generated by pathauto or not) are migrated with the content entity
    // migrations. Let's execute "user", "taxonomy_term" and "node" migrations.
    if ($this->multilingual) {
      $this->executeMigrations([
        'language',
        'd7_language_content_settings',
        'd7_language_content_taxonomy_vocabulary_settings',
      ]);
    }
    $this->executeMigration('d7_comment_type');
    if ($this->multilingual) {
      $this->executeMigrations([
        'd7_entity_translation_settings',
      ]);
    }
    $this->executeMigrations([
      'd7_filter_format',
      'd7_field',
      'd7_field_instance',
      'd7_view_modes',
      'd7_field_formatter_settings',
      'd7_field_instance_widget_settings',
      'd7_user_role',
      'user_picture_field',
      'user_picture_field_instance',
      'user_picture_entity_display',
      'user_picture_entity_form_display',
      'd7_node_title_label',
    ]);

    // Migrate files.
    $fs_fixture_path = $this->getFilesystemFixturePath();
    foreach (['d7_file', 'd7_file_private'] as $file_migration_plugin_id) {
      $file_migration = $this->getMigration($file_migration_plugin_id);
      $source = $file_migration->getSourceConfiguration();
      $source['constants']['source_base_path'] = $fs_fixture_path;
      $file_migration->set('source', $source);
      $this->executeMigration($file_migration);
    }

    // Ignore migration messages.
    $this->startCollectingMessages();
    $this->executeMigrations([
      'd7_user',
      'd7_node_complete',
      'd7_taxonomy_term',
    ]);
    if ($this->multilingual) {
      $this->executeMigrations([
        'd7_taxonomy_term_entity_translation',
        'd7_taxonomy_term_localized_translation',
        'd7_taxonomy_term_translation',
      ]);
    }
    // Migrate path aliases.
    $this->executeMigrations([
      'd7_url_alias',
    ]);
    $this->stopCollectingMessages();

    $path_alias_repository = $this->container->get('path_alias.repository');
    assert($path_alias_repository instanceof AliasRepository);

    // Check that the migrated URL aliases are present.
    $this->assertEquals('/term33', $path_alias_repository->lookupBySystemPath('/taxonomy/term/4', 'en')['alias']);
    $this->assertEquals('/term33', $path_alias_repository->lookupBySystemPath('/taxonomy/term/4', 'fr')['alias']);
    $this->assertEquals('/term33', $path_alias_repository->lookupBySystemPath('/taxonomy/term/4', 'is')['alias']);
    $this->assertEquals('/deep-space-9', $path_alias_repository->lookupBySystemPath('/node/2', 'en')['alias']);
    if ($this->multilingual) {
      $this->assertEquals('/deep-space-9-is', $path_alias_repository->lookupBySystemPath('/node/2', 'is')['alias']);
    }
    $this->assertEquals('/firefly-is', $path_alias_repository->lookupBySystemPath('/node/4', 'is')['alias']);
    $this->assertEquals('/firefly', $path_alias_repository->lookupBySystemPath('/node/4', 'en')['alias']);

    // Node 11 and taxonomy term 11 will have a generated path alias (after a
    // resave), since they have pathalias = 1 on the source site.
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/node/11', 'en'));
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/taxonomy/term/11', 'en'));
    Node::load(11)->save();
    Term::load(11)->save();
    $this->assertEquals('/entity-translation-test/11/page-one', $path_alias_repository->lookupBySystemPath('/node/11', 'en')['alias']);
    $this->assertEquals('/tag/dax', $path_alias_repository->lookupBySystemPath('/taxonomy/term/11', 'en')['alias']);

    // Taxonomy terms 2 and 3 do not have path alias, and their path alias state
    // is "0": They shoudn't get (new) path alias.
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/taxonomy/term/2', 'en'));
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/taxonomy/term/3', 'en'));
    Term::load(2)->save();
    Term::load(3)->save();
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/taxonomy/term/2', 'en'));
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/taxonomy/term/3', 'en'));

    // The French translation of node 8 (its node ID on source is "9") has
    // path auto state "0", but the other translations do not have states.
    // So node 8 should't get generated path aliases.
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/node/8', 'en'));
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/node/8', 'fr'));
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/node/8', 'is'));
    Node::load(8)->save();
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/node/8', 'en'));
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/node/8', 'fr'));
    $this->assertEquals(NULL, $path_alias_repository->lookupBySystemPath('/node/8', 'is'));
  }

  /**
   * Test multilingual pathauto pattern migrations.
   */
  public function testMultilingualPathautoMigrations() {
    $this->multilingual = TRUE;
    $module_installer = $this->container->get('module_installer');
    assert($module_installer instanceof ModuleInstallerInterface);
    $module_installer->install(['language']);
    $this->executeMigration('language');
    $this->testPathautoMigrations(TRUE);
    $this->assertAllNodeArticlePatterns();
  }

  /**
   * Data provider for ::testPathautoMigrations().
   *
   * @return bool[][]
   *   The test cases.
   */
  public function providerPathautoMigrations() {
    return [
      'Disabled forum on source site' => [
        'Forum enabled' => FALSE,
      ],
      'Enabled forum on source site' => [
        'Forum enabled' => TRUE,
      ],
    ];
  }

}
